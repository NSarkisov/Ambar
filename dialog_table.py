# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'dialog_table.ui'
#
# Created by: PyQt5 UI code generator 5.15.5
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from info_window import Change_window
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import  QMessageBox, QHeaderView, QVBoxLayout
from functools import partial
import sqlite3 as sl
from PyQt5.QtGui import QPixmap, QIcon, QImage 
from io import BytesIO
import io
from PyQt5.QtSql import QSqlDatabase, QSqlQueryModel, QSqlQuery

con = sl.connect('Manager.db')


class Ui_Dialog(object):
    TABLE = ""
    num = 0
    table_name = ""
    column_names = "" 
    querys = []
    
    
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(774, 559)
        self.tableWidget = QtWidgets.QTableWidget(Dialog)
        self.tableWidget.setGeometry(QtCore.QRect(30, 70, 711, 361))
        self.tableWidget.setObjectName("tableWidget")
        self.pushButton0 = QtWidgets.QPushButton(Dialog)
        self.pushButton0.setGeometry(QtCore.QRect(30, 20, 50, 28))
        self.pushButton0.setObjectName("pushButton0")
        self.pushButton_1 = QtWidgets.QPushButton(Dialog)
        self.pushButton_1.setGeometry(QtCore.QRect(300, 20, 131, 28))
        self.pushButton_1.setObjectName("pushButton_1")
        self.pushButton = QtWidgets.QPushButton(Dialog)
        self.pushButton.setGeometry(QtCore.QRect(602, 20, 131, 28))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(Dialog)
        self.pushButton_2.setGeometry(QtCore.QRect(450, 20, 131, 28))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_3 = QtWidgets.QPushButton(Dialog)
        self.pushButton_3.setGeometry(QtCore.QRect(600, 470, 131, 28))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_4 = QtWidgets.QPushButton(Dialog)
        self.pushButton_4.setEnabled(False)
        self.pushButton_4.setGeometry(QtCore.QRect(450, 470, 131, 28))
        self.pushButton_4.setObjectName("pushButton_4")
        self.textEdit = QtWidgets.QTextEdit(Dialog)
        self.textEdit.setGeometry(QtCore.QRect(30, 440, 401, 81))
        self.textEdit.setObjectName("textEdit")
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.show_table(self.TABLE, self.table_name)
        
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", self.table_name))
        self.pushButton0.setText(_translate("Dialog", "+"))
        self.pushButton_1.setText(_translate("Dialog", "Изменить"))
        self.pushButton.setText(_translate("Dialog", "Удалить"))
        self.pushButton_2.setText(_translate("Dialog", "Добавить"))
        self.pushButton_3.setText(_translate("Dialog", "Отменить"))
        self.pushButton_4.setText(_translate("Dialog", "Применить"))
        
        self.pushButton0.clicked.connect(partial(self.plus, self.table_name))
        self.pushButton_1.clicked.connect(partial(self.change, self.table_name, self.column_names))
        self.pushButton.clicked.connect(partial(self.delete, self.table_name))
        self.pushButton_2.clicked.connect(partial(self.add, self.table_name, self.column_names))
        self.pushButton_3.clicked.connect(partial(self.cancel))
        self.pushButton_4.clicked.connect(partial(self.apply)) 
        
    def show_table(self, TB, table_name):        
        self.tableWidget.setRowCount(len(TB))
        self.tableWidget.setColumnCount(len(TB[0]))
        # Заполнение таблицы данными
        info_dict = {}
        for row, data in enumerate(TB):
            if row not in info_dict.keys():
                info_dict[row] = data
            for col, value in enumerate(data):
                if isinstance(value, io.BytesIO):
                    item = QtWidgets.QTableWidgetItem("Картинка")
                    item.setData(Qt.UserRole, value)  # Сохраняем байты изображения в пользовательском роле
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                else:
                    item = QtWidgets.QTableWidgetItem(str(value))
                self.tableWidget.setItem(row, col, item) 
        if table_name =="Заказы":
            self.tableWidget.setColumnHidden(0, False) 
            self.pushButton_2.setEnabled(False) 
        else:
            self.tableWidget.setColumnHidden(0, True)    #скрытый столбец id от пользователя
         # Растягивание всех столбцов
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget.horizontalHeader().setVisible(False)
        #handle_cell_clicked, который вызывается при клике на ячейку таблицы. Обработчик получает индексы нажатой ячейки и затем использует метод setSelected(True) для каждой ячейки в столбце, чтобы выделить весь столбец.
        self.tableWidget.cellClicked.connect(partial(self.handle_cell_clicked, table_name, info_dict))   
    
             
    def handle_cell_clicked(self, table_name, info_dict, row, column):
        if column == 4:
            Dialog = QtWidgets.QDialog()
            change_window = Change_window() 
            for el in info_dict:
                if row == el:
                    id = info_dict[el][0]
                    name_cell = info_dict[el][1]
                    image = con.execute(f'SELECT "картинка" FROM {table_name} WHERE id = {id}').fetchall()[0][0] 
            change_window.image = BytesIO(image)
            change_window.name = name_cell
            change_window.table_name = table_name
            change_window.id_image = id
            
            change_window.setupChange(Dialog)
            Dialog.show()
            Dialog.exec_()
            
         # Выделение всего столбца    
        if row == 0:
            for row in range(self.tableWidget.rowCount()):
                item = self.tableWidget.item(row, column)
                if item:
                    item.setSelected(True)
    
    def plus(self, table_name):
        if table_name == 'Заказы':
            self.Dialog_add_order = QtWidgets.QDialog()
            self.Dialog_add_order.setObjectName("Dialog_add_order")
            self.Dialog_add_order.resize(450, 350) 
            self.Dialog_add_order.setWindowTitle("Добавление заказа")
            self.label = QtWidgets.QLabel(self.Dialog_add_order)
            self.label.setGeometry(QtCore.QRect(20, 80, 100, 16))
            self.label.setObjectName("label")
            self.label.setText("Выберите товар")
            self.label_1 = QtWidgets.QLabel(self.Dialog_add_order)
            self.label_1.setGeometry(QtCore.QRect(20, 120, 120, 28))
            self.label_1.setObjectName("label_1")
            self.label_1.setText("Количество")
            self.label_2 = QtWidgets.QLabel(self.Dialog_add_order)
            self.label_2.setGeometry(QtCore.QRect(20, 40, 120, 28))
            self.label_2.setObjectName("label_2")
            self.label_2.setText("Имя клиента")
            self.label_3 = QtWidgets.QLabel(self.Dialog_add_order)
            self.label_3.setGeometry(QtCore.QRect(20, 160, 120, 28))
            self.label_3.setObjectName("label_3")
            self.label_3.setText("Доступно")
            
            self.label_4 = QtWidgets.QLabel(self.Dialog_add_order)
            self.label_4.setGeometry(QtCore.QRect(20, 200, 120, 28))
            self.label_4.setObjectName("label_4")
            self.label_4.setText("Дата")
            self.dateEdit = QtWidgets.QDateEdit(self.Dialog_add_order)
            self.dateEdit.setGeometry(QtCore.QRect(130, 200, 255, 28))
            self.dateEdit.setObjectName("dateEdit")
            self.comboBox = QtWidgets.QComboBox(self.Dialog_add_order)
            self.comboBox.setGeometry(QtCore.QRect(130, 80, 255, 28))
            self.comboBox.setObjectName("comboBox")
            self.comboBox_1 = QtWidgets.QComboBox(self.Dialog_add_order)
            self.comboBox_1.setGeometry(QtCore.QRect(130, 40, 255, 28))
            self.comboBox_1.setObjectName("comboBox_1")  
            self.textEdit = QtWidgets.QTextEdit(self.Dialog_add_order)
            self.textEdit.setGeometry(QtCore.QRect(130, 160, 255, 28))
            self.textEdit.setObjectName("textEdit")
                      
            self.textEdit_1 = QtWidgets.QTextEdit(self.Dialog_add_order)
            self.textEdit_1.setGeometry(QtCore.QRect(130, 120, 255, 28))
            self.textEdit_1.setObjectName("textEdit_1")
            self.pushButton_6 = QtWidgets.QPushButton(self.Dialog_add_order)
            self.pushButton_6.setGeometry(QtCore.QRect(90, 250, 131, 28))
            self.pushButton_6.setObjectName("pushButton0")
            self.pushButton_6.setText("Ok")
            self.pushButton_7 = QtWidgets.QPushButton(self.Dialog_add_order)
            self.pushButton_7.setGeometry(QtCore.QRect(230, 250, 131, 28))
            self.pushButton_7.setObjectName("pushButton_1")
            self.pushButton_7.setText("Отмена")
            
            # self.model_goods = QSqlQueryModel()
            # self.comboBox.setModel(self.model_goods)
            self.comboBox.currentIndexChanged.connect(self.updateAmount)
            with con:
                goods = con.execute(f'SELECT имя_товара FROM Товары').fetchall()
                customers = con.execute(f'SELECT имя_клиента FROM Клиенты').fetchall()
               
                for good in goods:
                    self.comboBox.addItem(good[0])
                for customer in customers:
                    self.comboBox_1.addItem(customer[0])
                column_names = con.execute(f'PRAGMA table_info({table_name})').fetchall()
                column = [column[1] for column in column_names]  
            self.pushButton_6.clicked.connect(partial(self.add_in_table, self.table_name, column))
            self.pushButton_7.clicked.connect(partial(self.close))
            self.Dialog_add_order.exec_()
        else:
            table = self.tableWidget
            rowCount = table.rowCount()
            # Вставляем новую строку в таблицу
            table.insertRow(rowCount)
    
    def updateAmount(self, index):
        selected_good = self.comboBox.currentText()
        if selected_good:
            with con:
                info_amount = con.execute(f'SELECT количество, продано, перемещено, '
                                          f'списано FROM "Товар_на_складе" INNER JOIN Товары ON '
                                          f'Товар_на_складе.id_товара = Товары.id WHERE Товары.имя_товара = "{selected_good}"').fetchall()
                for el in info_amount:
                    amount = el[0]
                    sold = el[1]
                    moved = el[2]
                    written_off = el[3]
                available = amount - sold - moved - written_off
                self.textEdit.setPlainText(str(available))
        else:
            self.textEdit.clear()
                 
    def add_in_table(self, table_name, column):
        column = [i for i in column if i !='id']     #названия столбцов, кот необх добавить в запрос для внесения изменений в бд  
        column = ', '.join(column)
        print(column)
        name = self.comboBox_1.currentText()
        good = self.comboBox.currentText()
        amount = self.textEdit_1.toPlainText()
        date = self.dateEdit.date().toString('yyyy-MM-dd')
       
        with con:
            con.execute(f'INSERT INTO {table_name} ({column}) '
                        f'VALUES ((SELECT id FROM Клиенты WHERE имя_клиента = "{name}"), '
                        f'(SELECT id FROM Товары WHERE имя_товара = "{good}"), {amount}, "{date}")')
            #!!!!!Нужно добавить логику обработки столбца продано в табл Товары_на_складе
        #self.show_table(table_name)
        self.close()
            
                
    def close(self):
        self.Dialog_add_order.close()
    
    def is_data(self, table):     #забираю информацию из выделенного диапазона
        #возвращает список объектов QTableWidgetSelectionRange, представляющих выбранные диапазоны строк и столбцов в таблице.
        selected_ranges = table.selectedRanges() 
        data = []
        for selected_range in selected_ranges:
            top_row = selected_range.topRow()
            bottom_row = selected_range.bottomRow()
            left_column = selected_range.leftColumn()
            right_column = selected_range.rightColumn()    
        for row in range(top_row, bottom_row + 1):
            row_data = []
            for column in range(left_column, right_column + 1):
                item = table.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                else:
                    row_data.append('')
            data.append(row_data)
        return data
    
    def change(self, table_name, column_names):
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            if table_name == 'Заказы':
                pass
            else:
                column = column_names    
                for i in data:
                    #repr() возвращает строковое представление объекта, включая кавычки, если это строка, чтоб ? в запросе передавался в ""
                    val = ', '.join((repr(value) for value in i))
                    self.querys.append(f'UPDATE OR IGNORE {table_name} SET ({column}) = ({val}) WHERE id = {i[0]}')    
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)   
        else:
            # Если нет выделенных диапазонов, выводим сообщение пользователю
            QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')
           
    def add(self, table_name, column_names):  
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            column_names = column_names.split(',')
            column = [i for i in column_names if i !='id']     #названия столбцов, кот необх добавить в запрос для внесения изменений в бд  
            column = ', '.join(column)
            for sublist in data:
                for i in sublist[1:]:
                    #repr() возвращает строковое представление объекта, включая кавычки, если это строка, чтоб ? в запросе передавался в ""
                    val = ', '.join((repr(value) for value in sublist[1:]))
                self.querys.append(f'INSERT INTO {table_name} ({column}) VALUES ({val})')
               
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)    
        else:
            # Если нет выделенных диапазонов, выводим сообщение пользователю
            QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')
            
    def delete(self, table_name):
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            for sublist in data:
                id = sublist[0]
            #возвращает список объектов QTableWidgetSelectionRange, представляющих выбранные диапазоны строк и столбцов в таблице.
            self.querys.append(f'DELETE FROM {table_name} WHERE id = {id}')    
            # Активировать кнопки "Применить" и "Отменить"
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)
        else:
           QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')     
            
    def apply(self):
        for query in self.querys:
            print(query)
            with con:
                con.execute(query)
        self.querys = []    # очищаю список запросов на удаление после нажатия кнопки применить 
        selected_ranges = self.tableWidget.selectedRanges() 
        for selected_range in selected_ranges:
            top_row = selected_range.topRow()
            bottom_row = selected_range.bottomRow()
        #проходимся по каждому выбр диапаз строк в обрат порядке, начиная с нижней строки и удаляю кажд строку из табл.
        for row in range(bottom_row, top_row - 1, -1):
            self.tableWidget.removeRow(row)
         # Отключить кнопки "Применить" и "Отменить"
        self.pushButton_3.setEnabled(False)
        self.pushButton_4.setEnabled(False)
        
    def cancel(self):   
        self.querys = []
        dialog = self.tableWidget.window()
        dialog.close()
        self.pushButton_3.setEnabled(False)
        self.pushButton_4.setEnabled(False)
    
   
       
       
        



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())


