# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'dialog_table.ui'
#
# Created by: PyQt5 UI code generator 5.15.5
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import Qt
from PyQt5.QtWidgets import  QMessageBox, QHeaderView, QVBoxLayout
from functools import partial
import sqlite3 as sl
from PyQt5.QtGui import QPixmap, QIcon, QImage 
from io import BytesIO
from PIL import Image
import io

con = sl.connect('Manager.db')


class Ui_Dialog(object):
    TABLE = ""
    num = 0
    table_name = ""
    column_names = "" 
    querys = []
    image_viewer = None
    
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.resize(774, 559)
        self.tableWidget = QtWidgets.QTableWidget(Dialog)
        self.tableWidget.setGeometry(QtCore.QRect(30, 70, 711, 361))
        self.tableWidget.setObjectName("tableWidget")
        self.pushButton0 = QtWidgets.QPushButton(Dialog)
        self.pushButton0.setGeometry(QtCore.QRect(30, 20, 50, 28))
        self.pushButton0.setObjectName("pushButton0")
        self.pushButton_1 = QtWidgets.QPushButton(Dialog)
        self.pushButton_1.setGeometry(QtCore.QRect(300, 20, 131, 28))
        self.pushButton_1.setObjectName("pushButton0")
        self.pushButton = QtWidgets.QPushButton(Dialog)
        self.pushButton.setGeometry(QtCore.QRect(602, 20, 131, 28))
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(Dialog)
        self.pushButton_2.setGeometry(QtCore.QRect(450, 20, 131, 28))
        self.pushButton_2.setObjectName("pushButton_2")
        self.pushButton_3 = QtWidgets.QPushButton(Dialog)
        self.pushButton_3.setEnabled(False)
        self.pushButton_3.setGeometry(QtCore.QRect(600, 470, 131, 28))
        self.pushButton_3.setObjectName("pushButton_3")
        self.pushButton_4 = QtWidgets.QPushButton(Dialog)
        self.pushButton_4.setEnabled(False)
        self.pushButton_4.setGeometry(QtCore.QRect(450, 470, 131, 28))
        self.pushButton_4.setObjectName("pushButton_4")
        self.textEdit = QtWidgets.QTextEdit(Dialog)
        self.textEdit.setGeometry(QtCore.QRect(30, 440, 401, 81))
        self.textEdit.setObjectName("textEdit")
        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        self.show_table(self.TABLE)
        
    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", self.table_name))
        self.pushButton0.setText(_translate("Dialog", "+"))
        self.pushButton_1.setText(_translate("Dialog", "Изменить"))
        self.pushButton.setText(_translate("Dialog", "Удалить"))
        self.pushButton_2.setText(_translate("Dialog", "Добавить"))
        self.pushButton_3.setText(_translate("Dialog", "Отменить"))
        self.pushButton_4.setText(_translate("Dialog", "Применить"))
        
        self.pushButton0.clicked.connect(partial(self.plus))
        self.pushButton_1.clicked.connect(partial(self.change, self.table_name, self.column_names))
        self.pushButton.clicked.connect(partial(self.delete, self.table_name))
        self.pushButton_2.clicked.connect(partial(self.add, self.table_name, self.column_names))
        self.pushButton_3.clicked.connect(partial(self.cancel))
        self.pushButton_4.clicked.connect(partial(self.apply)) 
        
    def show_table(self, TB):        
        self.tableWidget.setRowCount(len(TB))
        self.tableWidget.setColumnCount(len(TB[0]))
        # Заполнение таблицы данными
        for row, data in enumerate(TB):
            for col, value in enumerate(data):
                if isinstance(value, io.BytesIO):
                    item = QtWidgets.QTableWidgetItem("Картинка")
                    item.setData(Qt.UserRole, value)  # Сохраняем байты изображения в пользовательском роле
                    item.setTextAlignment(Qt.AlignCenter)
                    item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                else:
                    item = QtWidgets.QTableWidgetItem(str(value))
                self.tableWidget.setItem(row, col, item)   
        self.tableWidget.setColumnHidden(0, True)    #скрытый столбец id от пользователя
         # Растягивание всех столбцов
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.tableWidget.horizontalHeader().setVisible(False)
        #handle_cell_clicked, который вызывается при клике на ячейку таблицы. Обработчик получает индексы нажатой ячейки и затем использует метод setSelected(True) для каждой ячейки в столбце, чтобы выделить весь столбец.
        self.tableWidget.cellClicked.connect(partial(self.handle_cell_clicked))   
    
             
    def handle_cell_clicked(self, row, column):
        item = self.tableWidget.item(row, column)
        if item and isinstance(item.data(Qt.UserRole), io.BytesIO):
            image_bytes = item.data(Qt.UserRole).read()
            image = QtGui.QImage.fromData(image_bytes)
            if image.isNull():
                return
            image = image.scaled(400, 300, QtCore.Qt.KeepAspectRatio)
            image_dialog = QtWidgets.QDialog()
            image_dialog.setWindowTitle("Изображение")
            label = QtWidgets.QLabel(image_dialog)
            label.setPixmap(QtGui.QPixmap.fromImage(image))
            label.setScaledContents(True)
            layout = QtWidgets.QVBoxLayout(image_dialog)
            layout.addWidget(label)
            image_dialog.exec_()
            
         # Выделение всего столбца    
        if row == 0:
            for row in range(self.tableWidget.rowCount()):
                item = self.tableWidget.item(row, column)
                if item:
                    item.setSelected(True)
    
    def plus(self):
        inputText = self.textEdit.toPlainText()
        self.textEdit.clear()
        # Получаем текущее количество строк в таблице
        table = self.tableWidget
        rowCount = table.rowCount()
        # Вставляем новую строку в таблицу
        table.insertRow(rowCount)
        values = inputText.split(',')
        # Запись значений из поля ввода в ячейки строки таблицы
        for column, value in enumerate(values):
            cell = QtWidgets.QTableWidgetItem(value.strip())
            table.setItem(rowCount, column, cell)
    
    def is_data(self, table):     #забираю информацию из выделенного диапазона
        #возвращает список объектов QTableWidgetSelectionRange, представляющих выбранные диапазоны строк и столбцов в таблице.
        selected_ranges = table.selectedRanges() 
        data = []
        for selected_range in selected_ranges:
            top_row = selected_range.topRow()
            bottom_row = selected_range.bottomRow()
            left_column = selected_range.leftColumn()
            right_column = selected_range.rightColumn()    
        for row in range(top_row, bottom_row + 1):
            row_data = []
            for column in range(left_column, right_column + 1):
                item = table.item(row, column)
                if item is not None:
                    row_data.append(item.text())
                else:
                    row_data.append('')
            data.append(row_data)
        return data
    
    def change(self, table_name, column_names):
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            column = column_names    
            for i in data:
                #repr() возвращает строковое представление объекта, включая кавычки, если это строка, чтоб ? в запросе передавался в ""
                val = ', '.join((repr(value) for value in i))
                self.querys.append(f'UPDATE {table_name} SET ({column}) = ({val}) WHERE id = {i[0]}')    
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)   
        else:
            # Если нет выделенных диапазонов, выводим сообщение пользователю
            QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')
           
    def add(self, table_name, column_names):   
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            column_names = column_names.split(',')
            column = [i for i in column_names if i !='id']     #названия столбцов, кот необх добавить в запрос для внесения изменений в бд  
            column = ', '.join(column)
            print(column)
            print(data)
            for sublist in data:
                for i in sublist[1:]:
                    #repr() возвращает строковое представление объекта, включая кавычки, если это строка, чтоб ? в запросе передавался в ""
                    val = ', '.join((repr(value) for value in sublist[1:]))
                self.querys.append(f'INSERT INTO {table_name} ({column}) VALUES ({val})')    
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)    
        else:
            # Если нет выделенных диапазонов, выводим сообщение пользователю
            QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')
            
    def delete(self, table_name):
        table = self.tableWidget 
        selected_model = table.selectionModel()
        selected_line = selected_model.selectedRows()
        if selected_line:
            data = self.is_data(table)
            for sublist in data:
                id = sublist[0]
            #возвращает список объектов QTableWidgetSelectionRange, представляющих выбранные диапазоны строк и столбцов в таблице.
            self.querys.append(f'DELETE FROM {table_name} WHERE id = {id}')    
            # Активировать кнопки "Применить" и "Отменить"
            self.pushButton_3.setEnabled(True)
            self.pushButton_4.setEnabled(True)
        else:
           QMessageBox.information(table, 'Внимание!', 'Пожалуйста, выделите строку.')     
            
    def apply(self):
        for query in self.querys:
            print(query)
            with con:
                con.execute(query)
        self.querys = []    # очищаю список запросов на удаление после нажатия кнопки применить 
        selected_ranges = self.tableWidget.selectedRanges() 
        for selected_range in selected_ranges:
            top_row = selected_range.topRow()
            bottom_row = selected_range.bottomRow()
        #проходимся по каждому выбр диапаз строк в обрат порядке, начиная с нижней строки и удаляю кажд строку из табл.
        for row in range(bottom_row, top_row - 1, -1):
            self.tableWidget.removeRow(row)
         # Отключить кнопки "Применить" и "Отменить"
        self.pushButton_3.setEnabled(False)
        self.pushButton_4.setEnabled(False)
        
    def cancel(self):
        self.querys = []
        self.pushButton_3.setEnabled(False)
        self.pushButton_4.setEnabled(False)
    
   
       
       
        



if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Dialog = QtWidgets.QDialog()
    ui = Ui_Dialog()
    ui.setupUi(Dialog)
    Dialog.show()
    sys.exit(app.exec_())


